(ns cljsbuild.core
  (:use
    [clojure.java.io :only [as-url resource]]
    [clj-stacktrace.repl :only [pst+]]
    [cljs.closure :only [build]]) 
  (:require
    [clojure.string :as string]
    [fs :as fs]))

(defn- filter-cljs [files types]
  (let [ext #(last (string/split % #"\."))]
    (filter #(types (ext %)) files)))

(defn- find-dir-cljs [root files types]
  (for [cljs (filter-cljs files types)] (fs/join root cljs)))

(defn- find-cljs [dir types]
  (let [iter (fs/iterdir dir)]
    (mapcat
      (fn [[root _ files]]
        (find-dir-cljs root files types))
      iter)))

(defn- elapsed [started-at]
  (let [elapsed-us (- (. System (nanoTime)) started-at)]
    (with-precision 2
      (str (/ (double elapsed-us) 1000000000) " seconds"))))

(defn- compile-cljs [cljs-path compiler-options]
  (let [output-file (:output-to compiler-options)
        output-dir (fs/dirname output-file)]
    (print (str "Compiling " output-file " from " cljs-path "...")) 
    (flush) 
    (when output-dir
      (fs/mkdirs output-dir ))
    (let [started-at (. System (nanoTime))]
      (try
        (build cljs-path compiler-options)
        (println (str " Done in " (elapsed started-at) "."))
        (catch Throwable e
          (println " Failed!")
          (pst+ e))))))

(defn- is-macro-file? [file]
  (not (neg? (.indexOf (slurp file) ";*CLJSBUILD-MACRO-FILE*;"))))

; There is a little bit of madness here to share macros between Clojure
; and ClojureScript.  The latter needs a  (:require-macros ...) whereas the
; former just wants  (:require ...).  Thus, we have a ;*CLJSBUILD-REMOVE*;
; conditional comment to allow different code to be used for ClojureScript files.
(defn- filtered-crossover-file [file]
  (str
    "; DO NOT EDIT THIS FILE! IT WAS AUTOMATICALLY GENERATED BY\n"
    "; lein-cljsbuild FROM THE FOLLOWING SOURCE FILE:\n"
    "; " file "\n\n"
    (string/replace (slurp file) ";*CLJSBUILD-REMOVE*;" "")))

(defn- crossover-to [cljs-path [from-parent from-resource]]
  (let [subpath (string/replace-first
                  (fs/abspath (.getPath from-resource))
                  (fs/abspath from-parent) "")
        to-file (fs/normpath
                  (fs/join (fs/abspath cljs-path) subpath))]
    (if (is-macro-file? from-resource)
      to-file
      (string/replace to-file #"\.clj$" ".cljs"))))

(defmacro dofor [seq-exprs body-expr]
  `(doall (for ~seq-exprs ~body-expr)))

(defn- ns-to-path [ns]
  (let [underscored (string/replace (str ns) #"-" "_")]
    (apply fs/join
      (string/split underscored #"\."))))

(defn- fail [& args]
  (throw (Exception. (apply str args))))

(defn- recurse-resource-dir [dir]
  (if dir
    ; We can't determine the contents of a jar dir.  Thus, crossover files
    ; in jars cannot be specified recursively; they have to be named file
    ; by file.
    (if (= (.getProtocol dir) "file")
      (let [path (.getPath dir)
            dirs (map #(as-url (str "file://" %)) (find-cljs path #{"clj"}))]
        dirs)
      [dir])))

(defn- truncate-uri-path [uri n]
  (if uri
    (let [uri-path (.getPath uri)]
      (subs uri-path 0 (- (.length uri-path) n)))
    nil))

(defn- find-crossover-resources [ns-path]
  (let [as-dir (resource ns-path)
        dir-parent (truncate-uri-path as-dir (.length ns-path))
        recurse-dirs (recurse-resource-dir as-dir)
        ns-file-path (str ns-path ".clj")
        as-file (resource ns-file-path)
        file-parent (truncate-uri-path as-file (.length ns-file-path))
        resources (conj
                    (map vector (repeat dir-parent) recurse-dirs)
                    [file-parent as-file])]
    (distinct
      (remove #(nil? (second %)) resources))))

(defn- crossover-needs-update? [from-resource to-file]
  (let [exists (fs/exists? to-file)]
    (or
      (not exists)
      (and
        ; We can't determine the mtime for jar resources; they'll just
        ; be copied once and that's it.
        (= "file" (.getProtocol from-resource))
        (> (fs/mtime (.getPath from-resource)) (fs/mtime to-file))))))

(defn- copy-crossovers [cljs-path crossovers]
  (dofor [crossover crossovers]
    (do
      (when (map? crossover)
        (fail "Sorry, crossovers now need to be specified by namespace rather than the old :from-dir/:to-dir map.")) 
      (let [ns-path (ns-to-path crossover)
            from-resources (find-crossover-resources ns-path)]
        (when (empty? from-resources)
          (fail "Unable to find crossover: " crossover))
        (let [to-files (map (partial crossover-to cljs-path) from-resources)]
          (doseq [dir (distinct (map fs/dirname to-files))]
            (fs/mkdirs dir)) 
          (dofor [[[_ from-resource] to-file] (zipmap from-resources to-files)]
            (when (crossover-needs-update? from-resource to-file)
              (spit to-file (filtered-crossover-file from-resource))
              :updated)))))))

(defn run-compiler [cljs-path crossovers compiler-options watch?]
  (println "Compiler started.")
  (loop [last-input-mtimes {}]
    (let [output-file (:output-to compiler-options)
          output-mtime (if (fs/exists? output-file) (fs/mtime output-file) 0)
          ; Need to return *.clj as well as *.cljs because ClojureScript
          ; macros are written in Clojure.
          input-files (find-cljs cljs-path #{"clj" "cljs"})
          input-mtimes (map fs/mtime input-files)
          crossover-updated? (some #{:updated}
                               (flatten
                                 (copy-crossovers cljs-path crossovers)))]
      (when (or
              (and
                (not= last-input-mtimes input-mtimes) 
                (some #(< output-mtime %) input-mtimes)) 
              crossover-updated?)
        (compile-cljs cljs-path compiler-options))
      (when watch?
        (Thread/sleep 100)
        (recur input-mtimes)))))
